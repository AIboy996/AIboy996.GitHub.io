---
tags:
- Leetcode
---

# [Least-K子数组](https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/)

给你一个整数数组 nums 和一个正整数 k 。

请你统计有多少满足 「 **nums中的最大元素** 」至少出现 k 次的子数组，并返回满足这一条件的子数组的数目。

子数组是数组中的一个连续元素序列。

## 题解

题目很简单，我们可以把题目增强一下：

统计有多少满足 「 **特定元素x** 」至少出现 k 次的子数组。

做起来和最大元素没什么区别。

### 双指针

使用双指针（或者叫滑动窗口）就可以解决这个问题：

```python
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        x = max(nums) # 这里寻找的是最大元素，其实可以换成任何一个指定元素
        right = curr = res = 0
        n = len(nums)
        for num in nums:
            while curr < k and right < n:
                curr += nums[right] == x
                right += 1
            if curr < k:
                break
            elif curr == k:
                res += n - (right - 1) 
                # right指针多走了一步
            curr -= num == x
        return res
```

核心思路：

- 为了找出所有的子数组`nums[left, right]`
- 我们遍历左指针
    - 每次保持左指针不动
    - 右指针一直往前移动，直到子数组满足条件【least k】；或者超出边界（说明从左指针往右一共也没有k个，可以结束遍历）
    - 如果`nums[left, right]`满足条件，那么`nums[left, right+j]`对`j>=1`都满足条件。因此我们找到了`n-right+1`个满足条件的子数组。
